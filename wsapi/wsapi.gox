// Copyright 2015 Factom Foundation
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE file.

package wsapi

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"strconv"

	factomapi "github.com/FactomProject/factomd/api"
	"github.com/FactomProject/factomd/btcd/wire"
	fct "github.com/FactomProject/factomd/common/factoid"
	fct "github.com/FactomProject/factomd/common/interfaces"
	"github.com/FactomProject/factomd/util"
	"github.com/hoisie/web"

	"github.com/FactomProject/factomd/common/constants"
	. "github.com/FactomProject/factomd/common/entryBlock"
	. "github.com/FactomProject/factomd/common/entryCreditBlock"
	"github.com/FactomProject/factomd/common/primitives"
	"github.com/FactomProject/factomd/state"
)

const (
	httpOK  = 200
	httpBad = 400
)

var (
	portNumber    = util.ReadConfig().Wsapi.PortNumber
	dataStorePath = "/tmp/store/seed/csv"
)

var _ = fmt.Println

var server = web.NewServer()

var (
	inMessageQ chan wire.FtmInternalMsg
	dbase      interfaces.DBOverlay
)

func Start(db interfaces.DBOverlay, inMsgQ chan wire.FtmInternalMsg) {
	factomapi.SetDB(db)
	dbase = db
	factomapi.SetInMsgQueue(inMsgQ)
	inMessageQ = inMsgQ

	wsLog.Debug("Setting Handlers")
	server.Post("/v1/commit-chain/?", handleCommitChain)
	server.Post("/v1/reveal-chain/?", handleRevealChain)
	server.Post("/v1/commit-entry/?", handleCommitEntry)
	server.Post("/v1/reveal-entry/?", handleRevealEntry)
	server.Post("/v1/factoid-submit/?", handleFactoidSubmit)
	server.Get("/v1/directory-block-head/?", handleDirectoryBlockHead)
	server.Get("/v1/get-raw-data/([^/]+)", handleGetRaw)
	server.Get("/v1/directory-block-by-keymr/([^/]+)", handleDirectoryBlock)
	server.Get("/v1/entry-block-by-keymr/([^/]+)", handleEntryBlock)
	server.Get("/v1/entry-by-hash/([^/]+)", handleEntry)
	server.Get("/v1/chain-head/([^/]+)", handleChainHead)
	server.Get("/v1/entry-credit-balance/([^/]+)", handleEntryCreditBalance)
	server.Get("/v1/factoid-balance/([^/]+)", handleFactoidBalance)
	server.Get("/v1/factoid-get-fee/", handleGetFee)

	wsLog.Info("Starting server")
	go server.Run("localhost:" + strconv.Itoa(portNumber))
}

func Stop() {
	server.Close()
}

func handleCommitChain(ctx *web.Context) {
	type commitchain struct {
		CommitChainMsg string
	}

	c := new(commitchain)
	if p, err := ioutil.ReadAll(ctx.Request.Body); err != nil {
		wsLog.Error(err)
		ctx.WriteHeader(httpBad)
		ctx.Write([]byte(err.Error()))
		return
	} else {
		if err := json.Unmarshal(p, c); err != nil {
			wsLog.Error(err)
			ctx.WriteHeader(httpBad)
			ctx.Write([]byte(err.Error()))
			return
		}
	}

	commit := NewCommitChain()
	if p, err := hex.DecodeString(c.CommitChainMsg); err != nil {
		wsLog.Error(err)
		ctx.WriteHeader(httpBad)
		ctx.Write([]byte(err.Error()))
		return
	} else {
		_, err := commit.UnmarshalBinaryData(p)
		if err != nil {
			wsLog.Error(err)
			ctx.WriteHeader(httpBad)
			ctx.Write([]byte(err.Error()))
			return
		}
	}

	if err := factomapi.CommitChain(commit); err != nil {
		wsLog.Error(err)
		ctx.WriteHeader(httpBad)
		ctx.Write([]byte(err.Error()))
		return
	}

	//	ctx.WriteHeader(httpOK)
}

func handleRevealChain(ctx *web.Context) {
	handleRevealEntry(ctx)
}

func handleCommitEntry(ctx *web.Context) {
	type commitentry struct {
		CommitEntryMsg string
	}

	c := new(commitentry)
	if p, err := ioutil.ReadAll(ctx.Request.Body); err != nil {
		wsLog.Error(err)
		ctx.WriteHeader(httpBad)
		ctx.Write([]byte(err.Error()))
		return
	} else {
		if err := json.Unmarshal(p, c); err != nil {
			wsLog.Error(err)
			ctx.WriteHeader(httpBad)
			ctx.Write([]byte(err.Error()))
			return
		}
	}

	commit := NewCommitEntry()
	if p, err := hex.DecodeString(c.CommitEntryMsg); err != nil {
		wsLog.Error(err)
		ctx.WriteHeader(httpBad)
		ctx.Write([]byte(err.Error()))
		return
	} else {
		_, err := commit.UnmarshalBinaryData(p)
		if err != nil {
			wsLog.Error(err)
			ctx.WriteHeader(httpBad)
			ctx.Write([]byte(err.Error()))
			return
		}
	}
	if err := factomapi.CommitEntry(commit); err != nil {
		wsLog.Error(err)
		ctx.WriteHeader(httpBad)
		ctx.Write([]byte(err.Error()))
		return
	}

}

func handleRevealEntry(ctx *web.Context) {
	type revealentry struct {
		Entry string
	}

	e := new(revealentry)
	if p, err := ioutil.ReadAll(ctx.Request.Body); err != nil {
		wsLog.Error(err)
		ctx.WriteHeader(httpBad)
		ctx.Write([]byte(err.Error()))
		return
	} else {
		if err := json.Unmarshal(p, e); err != nil {
			wsLog.Error(err)
			ctx.WriteHeader(httpBad)
			ctx.Write([]byte(err.Error()))
			return
		}
	}

	entry := NewEntry()
	if p, err := hex.DecodeString(e.Entry); err != nil {
		wsLog.Error(err)
		ctx.WriteHeader(httpBad)
		ctx.Write([]byte(err.Error()))
		return
	} else {
		_, err := entry.UnmarshalBinaryData(p)
		if err != nil {
			wsLog.Error(err)
			ctx.WriteHeader(httpBad)
			ctx.Write([]byte(err.Error()))
			return
		}
	}

	if err := factomapi.RevealEntry(entry); err != nil {
		wsLog.Error(err)
		ctx.WriteHeader(httpBad)
		ctx.Write([]byte(err.Error()))
		return
	}

	//	ctx.WriteHeader(httpOK)
}

func handleDirectoryBlockHead(ctx *web.Context) {
	type dbhead struct {
		KeyMR string
	}

	h := new(dbhead)
	if block, err := factomapi.DBlockHead(); err != nil {
		wsLog.Error(err)
		ctx.WriteHeader(httpBad)
		ctx.Write([]byte(err.Error()))
		return
	} else {
		h.KeyMR = block.KeyMR.String()
	}

	if p, err := json.Marshal(h); err != nil {
		wsLog.Error(err)
		ctx.WriteHeader(httpBad)
		ctx.Write([]byte(err.Error()))
		return
	} else {
		ctx.Write(p)
	}

	//	ctx.WriteHeader(httpOK)
}

type ecbal struct {
	Balance uint32
}

func handleEntryCreditBalance(ctx *web.Context, eckey string) {
	type ecbal struct {
		Response string
		Success  bool
	}
	var b ecbal
	adr, err := hex.DecodeString(eckey)
	if err == nil && len(adr) != constants.HASH_LENGTH {
		b = ecbal{Response: "Invalid Address", Success: false}
	}
	if err == nil {
		if bal, err := factomapi.ECBalance(eckey); err != nil {
			wsLog.Error(err)
			return
		} else {
			str := fmt.Sprintf("%d", bal)
			b = ecbal{Response: str, Success: true}
		}
	} else {
		b = ecbal{Response: err.Error(), Success: false}
	}

	if p, err := json.Marshal(b); err != nil {
		wsLog.Error(err)
		return
	} else {
		ctx.Write(p)
	}

}

func handleFactoidBalance(ctx *web.Context, eckey string) {
	type fbal struct {
		Response string
		Success  bool
	}
	var b fbal
	adr, err := hex.DecodeString(eckey)
	if err == nil && len(adr) != constants.HASH_LENGTH {
		b = fbal{Response: "Invalid Address", Success: false}
	}
	if err == nil {
		v := int64(state.FactoidStateGlobal.GetBalance(fct.NewAddress(adr)))
		str := fmt.Sprintf("%d", v)
		b = fbal{Response: str, Success: true}
	} else {
		b = fbal{Response: err.Error(), Success: false}
	}

	if p, err := json.Marshal(b); err != nil {
		wsLog.Error(err)
		return
	} else {
		ctx.Write(p)
	}

}

func returnMsg(ctx *web.Context, msg string, success bool) {
	type rtn struct {
		Response string
		Success  bool
	}
	r := rtn{Response: msg, Success: success}

	if p, err := json.Marshal(r); err != nil {
		wsLog.Error(err)
		return
	} else {
		ctx.Write(p)
	}
}

func handleFactoidSubmit(ctx *web.Context) {
	type x struct{ Transaction string }
	t := new(x)

	var p []byte
	var err error
	if p, err = ioutil.ReadAll(ctx.Request.Body); err != nil {
		wsLog.Error(err)
		returnMsg(ctx, "Unable to read the request", false)
		return
	} else {
		if err := json.Unmarshal(p, t); err != nil {
			returnMsg(ctx, "Unable to Unmarshal the request", false)
			return
		}
	}

	msg := new(wire.MsgFactoidTX)

	if p, err = hex.DecodeString(t.Transaction); err != nil {
		returnMsg(ctx, "Unable to decode the transaction", false)
		return
	}

	msg.Transaction = new(fct.Transaction)
	_, err = msg.Transaction.UnmarshalBinaryData(p)
	if err != nil {
		returnMsg(ctx, err.Error(), false)
		return
	}

	err = state.FactoidStateGlobal.Validate(1, msg.Transaction)
	if err != nil {
		returnMsg(ctx, err.Error(), false)
		return
	}

	inMessageQ <- msg

	returnMsg(ctx, "Successfully submitted the transaction", true)

}

func handleGetFee(ctx *web.Context) {
	type x struct{ Fee int64 }
	b := new(x)
	b.Fee = int64(state.FactoidStateGlobal.GetFactoshisPerEC())
	if p, err := json.Marshal(b); err != nil {
		wsLog.Error(err)
		ctx.WriteHeader(httpBad)
		return
	} else {
		ctx.Write(p)
	}
}

func handleGetRaw(ctx *web.Context, hashkey string) {
	type rawData struct {
		Data string
	}
	//TODO: var block interfaces.BinaryMarshallable
	d := new(rawData)

	h, err := primitives.HexToHash(hashkey)
	if err != nil {
		wsLog.Error(err)
		ctx.WriteHeader(httpBad)
		ctx.Write([]byte(err.Error()))
		return
	}

	// try to find the block data in db and return the first one found
	if block, _ := dbase.FetchFBlockByHash(h); block != nil {
		bytes, _ := block.MarshalBinary()
		d.Data = hex.EncodeToString(bytes[:])
	} else if block, _ := dbase.FetchDBlockByHash(h); block != nil {
		bytes, _ := block.MarshalBinary()
		d.Data = hex.EncodeToString(bytes[:])
	} else if block, _ := dbase.FetchABlockByHash(h); block != nil {
		bytes, _ := block.MarshalBinary()
		d.Data = hex.EncodeToString(bytes[:])
	} else if block, _ := dbase.FetchDBlockByMR(h); block != nil {
		bytes, _ := block.MarshalBinary()
		d.Data = hex.EncodeToString(bytes[:])
	} else if block, _ := dbase.FetchEBlockByHash(h); block != nil {
		bytes, _ := block.MarshalBinary()
		d.Data = hex.EncodeToString(bytes[:])
	} else if block, _ := dbase.FetchEBlockByMR(h); block != nil {
		bytes, _ := block.MarshalBinary()
		d.Data = hex.EncodeToString(bytes[:])
	} else if block, _ := dbase.FetchECBlockByHash(h); block != nil {
		bytes, _ := block.MarshalBinary()
		d.Data = hex.EncodeToString(bytes[:])
	} else if block, _ := dbase.FetchEntryByHash(h); block != nil {
		bytes, _ := block.MarshalBinary()
		d.Data = hex.EncodeToString(bytes[:])
	}

	if p, err := json.Marshal(d); err != nil {
		wsLog.Error(err)
		ctx.WriteHeader(httpBad)
		ctx.Write([]byte(err.Error()))
		return
	} else {
		ctx.Write(p)
	}

	//	ctx.WriteHeader(httpOK)
}
