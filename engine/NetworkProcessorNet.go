// Copyright 2015 Factom Foundation
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE file.

package engine

import (
	"fmt"
	"math/rand"
	"time"
	"github.com/FactomProject/factomd/log"
)

var _ = log.Printf
var _ = fmt.Print

func NetworkProcessorNet(fnode *FactomNode) {
    go Peers(fnode)
    go NetworkOutputs(fnode)
    go InvalidOutputs(fnode)
}

func Peers(fnode *FactomNode) {    
	for {
        time.Sleep(10*time.Millisecond)
		cnt := 0
		// Put any broadcasts from our peers into our BroadcastIn queue
		for i, peer := range fnode.Peers {
			for j := 0; j < 100; j++ {
				msg, err := peer.Recieve()

				if err == nil && msg != nil {
					msg.SetOrigin(i + 1)
					if fnode.State.Replay.IsTSValid_(msg.GetMsgHash().Fixed(),
						int64(msg.GetTimestamp())/1000,
						int64(fnode.State.GetTimestamp())/1000) {
						//if state.GetOut() {
						//	fnode.State.Println("In Comming!! ",msg)
						//}
						nme := fmt.Sprintf("%s %d", "PeerIn", i+1)
						fnode.MLog.add2(fnode, false, peer.GetNameTo(), nme, true, msg)

						fnode.State.InMsgQueue() <- msg

					} else {
						fnode.MLog.add2(fnode, false, peer.GetNameTo(), "PeerIn", false, msg)
					}
					cnt++
				} else {
					if err != nil {
						fmt.Println(fnode.State.GetFactomNodeName(), err)
					}
					break
				}
			}
		}
    }
}

func NetworkOutputs(fnode *FactomNode) {
		for {
        time.Sleep(10*time.Millisecond)
			msg := <-fnode.State.NetworkOutMsgQueue()
				// Local Messages are Not broadcast out.  This is mostly the block signature
				// generated by the timer for the leaders which needs to be processed, but replaced
				// by an updated version when the block is ready.
			if !msg.IsLocal() {
				if rand.Int()%1000 < fnode.State.GetDropRate() {
				    //drop the message, rather than processing it normally
				} else {
					// We don't care about the result, but we do want to log that we have
					// seen this message before, because we might have generated the message
					// ourselves.
					fnode.State.Replay.IsTSValid_(
                        msg.GetMsgHash().Fixed(),
          				int64(msg.GetTimestamp())/1000,
						int64(fnode.State.GetTimestamp())/1000)

					if msg.IsPeer2peer() {
			    		p := msg.GetOrigin() - 1
						if len(fnode.Peers) == 0 {
							fnode.State.Print("-n- Sleepy ")
						}else{
                            if p < 0 {
                                p = rand.Int() % len(fnode.Peers)
                            }

							fnode.MLog.add2(fnode, true, fnode.Peers[p].GetNameTo(), "P2P out", true, msg)
							fnode.Peers[p].Send(msg)
                        }
					} else {
                        p := msg.GetOrigin() - 1
                        for i, peer := range fnode.Peers {
                            // Don't resend to the node that sent it to you.
                            if i != p || true {
                                bco := fmt.Sprintf("%s/%d/%d", "BCast", p, i)
                                fnode.MLog.add2(fnode, true, peer.GetNameTo(), bco, true, msg)
                                peer.Send(msg)
                            }
						}
					}
				}
			}
        }
}	
        
// Just throw away the trash        
func InvalidOutputs(fnode *FactomNode) {
	for {
        time.Sleep(10*time.Millisecond)
	    <-fnode.State.NetworkInvalidMsgQueue()			
	}
}
