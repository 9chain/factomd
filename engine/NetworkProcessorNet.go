// Copyright 2015 Factom Foundation
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE file.

package engine

import (
	"fmt"
	"math/rand"
	"time"

	"github.com/FactomProject/factomd/common/messages"
	"github.com/FactomProject/factomd/common/primitives"
	"github.com/FactomProject/factomd/log"
)

var _ = log.Printf
var _ = fmt.Print

func NetworkProcessorNet(fnode *FactomNode) {
	go Peers(fnode)
	go NetworkOutputs(fnode)
	go InvalidOutputs(fnode)
}

func Peers(fnode *FactomNode) {
	for {
		time.Sleep(10 * time.Millisecond)
		cnt := 0
		// Put any broadcasts from our peers into our BroadcastIn queue
		for i, peer := range fnode.Peers {
			for j := 0; j < 100; j++ {
				msg, err := peer.Recieve()
				if err == nil && msg != nil {

					msg.SetOrigin(i + 1)
					if fnode.State.Replay.IsTSValid_(msg.GetMsgHash().Fixed(),
						int64(msg.GetTimestamp())/1000,
						int64(fnode.State.GetTimestamp())/1000) {
						//if state.GetOut() {
						//	fnode.State.Println("In Comming!! ",msg)
						//}
						in := "PeerIn"
						if msg.IsPeer2peer() {
							in = "P2P In"
						}
						nme := fmt.Sprintf("%s %d", in, i+1)

						fnode.MLog.add2(fnode, false, peer.GetNameTo(), nme, true, msg)

						// Ignore messages if there are too many.
						if len(fnode.State.InMsgQueue()) < 9000 {
							fnode.State.InMsgQueue() <- msg
						}

					} else {
						fnode.MLog.add2(fnode, false, peer.GetNameTo(), "PeerIn", false, msg)
					}
					cnt++
				} else {
					break
				}
			}
		}
	}
}

func NetworkOutputs(fnode *FactomNode) {
	for {
		if len(fnode.State.NetworkOutMsgQueue()) > 500 {
			fmt.Print(fnode.State.GetFactomNodeName(), "-", len(fnode.State.NetworkOutMsgQueue()), " ")
		}
		time.Sleep(10 * time.Millisecond)
		msg := <-fnode.State.NetworkOutMsgQueue()
		// Local Messages are Not broadcast out.  This is mostly the block signature
		// generated by the timer for the leaders which needs to be processed, but replaced
		// by an updated version when the block is ready.
		if fnode.State.FactomNodeName == "FNode8" { //} && fnode.State. { //} && len(fnode.Peers) > 4 {
			//h, err := primitives.HexToHash("d10d57abfa7974b6ae90ef8754b0ab7e0f618e701d8252c5890149201d039c62")
			//h, err := primitives.HexToHash("4e96400f59dd46f99d223ff912f678a20538e1802e2d9e29edfb4b7a3d5822c7")
			h, err := primitives.HexToHash("82cfe17ecc7f87715b124d2b291a5de5ef599db4ab163b8573fd182b55c0a49f")

			if err == nil {
				myE, myI, err := fnode.State.LoadDataByHash(h)
				if err == nil {
					dr := messages.NewDataResponse(fnode.State, myE, myI, h)
					for pi := range fnode.Peers {
						fnode.Peers[pi].Send(dr)
					}
				}
			}
		}
		if !msg.IsLocal() {
			if rand.Int()%1000 < fnode.State.GetDropRate() {
				//drop the message, rather than processing it normally
			} else {
				// We don't care about the result, but we do want to log that we have
				// seen this message before, because we might have generated the message
				// ourselves.
				fnode.State.Replay.IsTSValid_(
					msg.GetMsgHash().Fixed(),
					int64(msg.GetTimestamp())/1000,
					int64(fnode.State.GetTimestamp())/1000)

				p := msg.GetOrigin() - 1

				if msg.IsPeer2peer() {
					// Must have a Peer to send a message to a peer
					if len(fnode.Peers) > 0 {
						if p < 0 {
							p = rand.Int() % len(fnode.Peers)
						}
						fnode.MLog.add2(fnode, true, fnode.Peers[p].GetNameTo(), "P2P out", true, msg)

						fnode.Peers[p].Send(msg)

					}
				} else {
					for i, peer := range fnode.Peers {
						// Don't resend to the node that sent it to you.
						if i != p {
							bco := fmt.Sprintf("%s/%d/%d", "BCast", p, i)
							fnode.MLog.add2(fnode, true, peer.GetNameTo(), bco, true, msg)
							peer.Send(msg)
						}
					}
				}
			}
		}
	}
}

// Just throw away the trash
func InvalidOutputs(fnode *FactomNode) {
	for {
		time.Sleep(10 * time.Millisecond)
		<-fnode.State.NetworkInvalidMsgQueue()
	}
}
